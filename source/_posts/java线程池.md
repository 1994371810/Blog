---
title: java线程池
date: 2020-04-12 10:58:45
categories:
- java
---

# 多线程

## 两种线程模型

线程分为用户级线程(ULT)和内核级线程(KLT)

**用户线程(ULT): 用户程序实现，不依赖操作系统核心，应用提供创建，同步，调度和管理线程和函数来控制用户线程，不需要用户态/内核态切换，速度快，内核对ULT无感知。线程阻塞则进程阻塞(某个app创建的线程,由app管理)**

**内核线程(KLT): 系统内核管理线程，内核保存线程的状态和上下文信息。线程阻塞不会引起进程阻塞，在多处理器上，多线程处理器上并行运行，线程的创建，调度和管理由内核完成，效率比ULT慢，比进程操作快(由系统内核管理**)

简单来说：用户线程由app创建并运行，与内核无关，运行速度快，内核线程由app创建并交给内核处理，内核会保存内核线程的**线程状态**和**上下文信息**所以运行速度较低

java的jvm虚拟机使用的都是KLT模型   



## 线程池

### 为什么使用线程池

1 多个线程同时执行时，cpu会进行线程切换，并且还要管理线程的执行和销毁，是比较耗费性能的，线程在创建时，会向内核的线程注册表内注册，cpu会算出每个线程的执行时间，并对线程注册表内的线程进行调用，如果在指定时间内该线程没有执行完，cpu就会切换线程执行 这是十分消耗性能的

线程是稀缺资源，他的创建和销毁是一个相对于篇重且消耗资源的操作，而java线程依赖于内核线程，要进行操作系统状态切换，为避免资源过度消费，需要设法重用线程执行多个任务，线程池就是一个负责对线程进行统一分配，调优与监控

### 什么时候使用线程池

1. 单个任务处理时间较短
2. 需要处理的任务数量大

### 线程池的优势

- 重用存在的线程，减少线程创建，消亡的开销，提高性能
- 提高相应速度，当任务到达时，任务可以不需要等到线程创建就立即执行
- 提高线程可管理性，可统一分配，调优和监控

### Java创建线程池

可以通过创建ThreadPoolExecutor创建线程

```java
 //核心线程数 最大线程数 没任务空闲多久后停止工作  处理不过来放入哪个阻塞队列(不管并发量多大，永远只有一个线程能够进行队列的入队和出队操作，线程安全，如果队列满了，则添加操作阻塞，如果队列为空，获取数据阻塞)
ThreadPoolExecutor executor = new ThreadPoolExecutor(5,10,2000,TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>(10));
//核心线程数和最大线程数的区别： 当线程池内任务较少时只会创建核心线程,如果待执行队列内放满，线程池会创建非核心线程数(最大线程数-核心线程数=非核心线程数)直接执行任务,一旦任务被执行的差不多了，就会将非核心现超消灭，只留下核心线程
```

![](C:\Users\pc\OneDrive\桌面\java\线程池结构图.png)



**线程池工作原理：**通过线程池的execute方法传入一个Runnable线程后，会先创建核心线程执行任务，如果核心线程已满，会先将任务放入阻塞队列内，如果阻塞队列已满，会创建非核心线程执行任务，所以**线程池同时最大能同时接收的任务为最大线程数+队列长度**，一旦任务超过这个值会调用淘汰策略淘汰多余的线程任务(默认抛异常)



### 线程池的5中状态

- Running: 能接受新任务以及处理已添加的任务
- Shutdowm: 不能接受新任务，可以处理已添加的任务
- Stop：不能接受新任务，不处理已添加的任务，并且中断正在处理的任务
- Tidying: 所以的任务已经终止，ctl记录的‘任务数量’ 为0，ctl负责记录线程池的运行状态与活动线程数量
- Terminated: 线程池彻底终止

![](C:\Users\pc\OneDrive\桌面\java\线程池状态.png)

 shut down方法是停止接收线程任务，将以接受的线程任务执行完毕后进入ShutDown

shutdownNow方法是停止接收线程，并且停止执行任务进入stop











